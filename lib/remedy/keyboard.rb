require 'remedy/console'
require 'remedy/key'

module Remedy
  module Keyboard
    module_function

    # Gets the raw input from the terminal and parses it.
    #
    # @return [Key] the most recent input as an object
    def get
      parse raw_get
    end

    # Initiates a raw transaction with the terminal and captures a single event. Some events are multiple bytes.
    # `#raw_get` can handle up to 3 byte events.
    # This supports interactive terminal input use cases like arrow keys and complex keyboard shortcuts.
    # While most events are initiated by the user from the keyboard, some events may be inititated by the terminal itself.
    #
    # @return [String] the bytes of the terminal event
    def raw_get
      Console.raw do
        input = STDIN.getc.chr

        if input == "\e" then
          input << STDIN.read_nonblock(3) rescue nil
          input << STDIN.read_nonblock(2) rescue nil
        end

        input
      end
    end

    # Parse a sequence of bytes into a Key object.
    #
    # @param sequence [String] a set of bytes representing a single keyboard or terminal event
    # @return [Key] the sequence input as a Key object
    # @raise [UnrecognizedInput] if {raise_on_unrecognized_key!} has been called and the user presses a key that Key doesn't understand (mostly for debugging)
    # @raise [ControlC] if {raise_on_control_c!} has been called and the user presses control-c (good default so the user can exit the program without extra code)
    def parse sequence
      key = Key.new sequence

      if raise_on_control_c? && key.control_c? then
        raise ControlC, "User pressed Control-C"
      elsif key.recognized? then
        key
      elsif raise_on_unrecognized_key? then
        raise UnrecognizedInput, %Q{Unknown key or byte sequence: "#{sequence}" : #{key.inspect}}
      else
        key
      end
    end

    # Getter to check if the `raise_on_unrecognized_key` flag is set.
    #
    # @return [Boolean]
    def raise_on_unrecognized_key?
      @raise_on_unrecognized_key
    end

    # Set the `raise_on_unrecognized_key` flag so that {parse} will raise an {UnrecognizedInput} error
    # if it receives a `sequence` input that {Key} does not know about.
    #
    # @return true
    def raise_on_unrecognized_key!
      @raise_on_unrecognized_key = true
    end

    # Disables the `raise_on_unrecognized_key` flag to prevent {parse} from raising {UnrecognizedInput} errors.
    #
    # @note This is the default state.
    #
    # @return false
    def dont_raise_on_unrecognized_key!
      @raise_on_unrecognized_key = false
    end

    # Getter to check if the `raise_on_control_c` flag is set.
    #
    # @return [Boolean]
    def raise_on_control_c?
      @raise_on_control_c
    end

    # Set the `raise_on_control_c` flag so that {parse} will raise a {ControlC} error
    # if it receives a control-c as its sequence input.
    #
    # @return true
    def raise_on_control_c!
      @raise_on_control_c = true
    end

    # Disables the `raise_on_control_c` flag to prevent {parse} from raising {ControlC} errors.
    #
    # @note This is the default state.
    #
    # @note {Interaction#loop} sets this flag to `true`.
    #
    # @return false
    def dont_raise_on_control_c!
      @raise_on_control_c = false
    end

    # An exception subclass of {Interrupt} which represents the user pressing control-c.
    # Generated by {Keyboard}'s {Keyboard.parse} method if the {Keyboard.raise_on_unrecognized_key?} flag is set..
    class ControlC < Interrupt; end

    # An exception subclass of {Interrupt} which represents the user pressing a key that is not recognized by {Key}.
    # Generated by {Keyboard}'s {Keyboard.parse} method if the {Keyboard.raise_on_control_c?} flag is set.
    class UnrecognizedInput < IOError; end
  end
end
